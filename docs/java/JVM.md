- [内存结构](#内存结构)
  - [程序计数器PC](#程序计数器pc)
  - [Java虚拟机栈(Java 栈)](#java虚拟机栈java-栈)
    - [方法的调用](#方法的调用)
    - [Java虚拟机栈的特点](#java虚拟机栈的特点)
  - [本地方法栈(C栈)](#本地方法栈c栈)
  - [堆](#堆)
    - [特点](#特点)
    - [新生代和老年代](#新生代和老年代)
    - [Full GC和Major GC](#full-gc和major-gc)
    - [逃逸分析](#逃逸分析)

# 内存结构

## 程序计数器PC

**定义**

是当前线程正在执行的那条**字节码**指令的地址。若当前线程正在执行的是一个本地方法，那么此时程序计数器为`Undefined`

[字节码解释器]()通过改变PC来依次读取指令，实现流程控制

**特点**

- 线程私有
- 生命周期随着线程创建而创建、结束而销毁
- 唯一不会`OutOfMemoryError`的内存区域

## Java虚拟机栈(Java 栈)

为每个即将运行的Java方法创建一个**栈帧**区域，如下图所示：

![20230412150205](https://raw.githubusercontent.com/PercivalYang/imgsSaving/main/imgs/20230412150205.png)

**活动栈**

当前栈帧又称**活动栈**，即当前正在执行的方法，只有这个栈帧中的本地变量能够被**操作数栈**使用。当方法结束栈帧被弹出时，当前方法的返回值会作为下一个活动栈中操作数栈的一个操作数。

**局部变量表**

用于存储方法参数、定义在方法体内的局部变量。如图所示包含了3种数据类型：基本类型、对象引用和return Address

> return Address: 通常视为一个指向地址的指针，指示程序执行完方法后该回到哪个位置继续执行

表的容量大小在**编译期间**就定下来了，方法运行期间表的大小不会改变

基本的存储单位是：`slot`。32位数据类型占1个slot，64位数据类型(long, double)占2个slot。

对于slot：

- JVM会对每一个slot分配一个访问索引，通过索引可以访问到局部变量值
- 当一个局部变量过了作用域后，它所占用的slot是可以被新的局部变量覆盖
- 若活动栈是构造方法，那么第一个slot是用来存储`this`的引用的 (这个目的是什么？)

局部变量表中直接或间接引用的对象，都不会被GC回收，因为这些变量是根结点。

**操作数栈**

用于存储计算过程中的中间结果，也是方法调用时的参数传递。操作数栈的容量大小也是在**编译期间**就确定下来了。32位数据类型占一个栈单位，64占两个栈单位。

- 栈顶缓存：因为操作数存储在内存中，为提高效率减小读写内存的次数，将栈顶元素缓存到CPU寄存器中来提高执行效率；
- 存储单位是栈，访问的方式不再是通过索引访问，而是入栈、出栈的方式，例如子程序返回的值会先入主程序的操作数栈，然后再出栈返回给主程序的变量值。

### 方法的调用

**静态链接**

被调用的方法在编译期可知，且运行期不变，称为静态链接。如：`System.out.println()`等静态方法。

> 会直接在编译期将调用方法的符号引用转换为直接引用（称为**早期绑定**）

**动态链接**

被调用的方法无法在编译期间确定，例如接口、继承和反射等，只能在运行期将调用方法的符号引用转换为直接引用（称为**晚期绑定**）。这种称为动态链接。

> 接口和继承是当子类实现/重写了父类的方法时，可能会出现动态链接

**非虚方法**

非虚方法通常包括：静态方法、`private`方法、`final`方法、构造方法等。因为这些方法无法被子类重写，在编译期就可以确定方法的版本，因此就不存在动态链接。

除开上述提到的非虚方法，Java中任意一个普通方法都是虚方法（晚期绑定）

**虚方法表**

为了提高执行效率，避免每次动态分配过程都要去类中方法的元数据中搜索，JVM会为每个类维护一个虚方法表。

- 表中存放各虚方法的实际入口
- 表在类加载的**链接阶段**创建和初始化

**方法重写的本质**（[待完善](https://doocs.gitee.io/jvm/01-jvm-memory-structure.html#%E6%96%B9%E6%B3%95%E7%9A%84%E8%B0%83%E7%94%A8)）

### Java虚拟机栈的特点

- 会出现的两种异常: `StackOverFlowError`, `OutOfMemoryError`
  - `StackOverFlow`: 设置了Java虚拟机栈的大小不允许**动态扩展**，当线程请求的栈深度超过Java虚拟机栈的最大深度时会抛出该异常；
  - `OutOfMemory`: 允许Java虚拟机栈动态扩展，但是当扩展到内存用光的时候，就会抛出该异常
- Java虚拟机栈是线程私有的，生命周期同线程一样

## 本地方法栈(C栈)

**定义**

本地方法栈是为运行`native`方法准备的空间，`native`方法通常是由C语言实现。

与Java虚拟栈功能类似，两者都是内存模型。区别在于Java虚拟栈为Java方法服务，本地方法栈为`native`方法服务。

本地方法执行时，同样会创建活动栈用于存放局部变量表、操作数栈、动态链接、方法出口信息等。方法结束后出栈释放资源。同时也会抛出`StackOverFlow`和`OutOfMemory`异常。

## 堆

### 特点

- 线程共享的，在JVM启动时创建，是GC的主要区域
- 分为新生代(Eden区：`From Survior`, `To Survior`)、老年代
- 堆可以在运行时动态扩展或收缩，但是在扩展时可能会出现`OutOfMemory`异常
- 堆可以处于物理不连续的内存空间，但是逻辑上是连续的

### 新生代和老年代

- 老年代生命周期更长；
- 新生代与老年代空间**默认比例 1:2**。XX:NewRatio=2，用来设置新生代和老年代内存大小比例，此处表示老年代的内存大小是新生代的2倍，则新生代占整个堆内存的1/3；
- HotSpot 中，Eden 空间和另外两个 Survivor 空间缺省所占的比例是：8:1:1。

> 这里的Eden空间和另外两个Survivor空间是否能补上图片说明？

- 几乎所有的 Java 对象都是在 Eden 区被 new 出来的，Eden 放不了的大对象，就直接进入老年代了。

### Full GC和Major GC

**触发条件**

- 老年代和方法区内存不足 $\rightarrow$ 触发Full GC；
- 回收新生代区会用Minor GC，当老年代内存还是不够时触发Major GC

**STW(Stop The World)**

- Full GC和Major GC都会触发STW，即在GC之前，所有的线程都会被暂停，直到GC结束，所有的线程才会被唤醒；
- Full GC STW 时间最长，Major GC STW 时间次之，Minor GC STW 时间最短。

### 逃逸分析

**方法逃逸**指对象定义在一个方法中，但是它可能被外部方法所引用，例如作为参数传递给外部方法，则称作方法逃逸，例如：（类似的还有**线程逃逸**）

```java
public static StringBuffer createStringBuffer(String s1, String s2) {

    StringBuffer s = new StringBuffer();

    s.append(s1);

    s.append(s2);

    return s;
}
```

> s是方法内的局部变量，但是上述代码将s作为返回值进行返回，即s可能会被外部方法所引用，因此发生了`方法逃逸`

逃逸分析是一种基于**指针分析**的**优化技术**，它的目的是分析**对象的作用域**，以此来决定是否在栈上分配对象，还是在堆上分配对象。

**标量替换**

标量对应Java中的基本数据类型，意思是不可再分的量。与之对应的就是**聚合量**，即可再分的量，如数组、对象等。

**替换过程**是通过逃逸分析确定该对象不会被外部访问，JVM在方法内不会创建该对象，而是分解对象的成员变量为方法内的替代变量。这样就不需要在堆上分配内存了，这些替代变量在栈或寄存器上分配空间

- 对象和数组不一定会分配在堆上，如果对象不会逃逸出方法，那么它就分配在栈上，这样就不需要GC来回收了。

**参数设置**

- `-XX:+DoEscapeAnalysis`：开启逃逸分析，jdk1.7之后默认开启；（`+`换成`-`就是关闭）
