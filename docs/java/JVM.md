- [内存结构](#内存结构)
  - [程序计数器PC](#程序计数器pc)
  - [Java虚拟机栈(Java 栈)](#java虚拟机栈java-栈)
    - [方法的调用](#方法的调用)
    - [Java虚拟机栈的特点](#java虚拟机栈的特点)
  - [本地方法栈(C栈)](#本地方法栈c栈)

# 内存结构

## 程序计数器PC

**定义**

是当前线程正在执行的那条**字节码**指令的地址。若当前线程正在执行的是一个本地方法，那么此时程序计数器为`Undefined`

[字节码解释器]()通过改变PC来依次读取指令，实现流程控制

**特点**

- 线程私有
- 生命周期随着线程创建而创建、结束而销毁
- 唯一不会`OutOfMemoryError`的内存区域

## Java虚拟机栈(Java 栈)

为每个即将运行的Java方法创建一个**栈帧**区域，如下图所示：

![20230412150205](https://raw.githubusercontent.com/PercivalYang/imgsSaving/main/imgs/20230412150205.png)

**活动栈**

当前栈帧又称**活动栈**，即当前正在执行的方法，只有这个栈帧中的本地变量能够被**操作数栈**使用。当方法结束栈帧被弹出时，当前方法的返回值会作为下一个活动栈中操作数栈的一个操作数。

**局部变量表**

用于存储方法参数、定义在方法体内的局部变量。如图所示包含了3种数据类型：基本类型、对象引用和return Address

> return Address: 通常视为一个指向地址的指针，指示程序执行完方法后该回到哪个位置继续执行

表的容量大小在**编译期间**就定下来了，方法运行期间表的大小不会改变

基本的存储单位是：`slot`。32位数据类型占1个slot，64位数据类型(long, double)占2个slot。

对于slot：

- JVM会对每一个slot分配一个访问索引，通过索引可以访问到局部变量值
- 当一个局部变量过了作用域后，它所占用的slot是可以被新的局部变量覆盖
- 若活动栈是构造方法，那么第一个slot是用来存储`this`的引用的 (这个目的是什么？)

局部变量表中直接或间接引用的对象，都不会被GC回收，因为这些变量是根结点。

**操作数栈**

用于存储计算过程中的中间结果，也是方法调用时的参数传递。操作数栈的容量大小也是在**编译期间**就确定下来了。32位数据类型占一个栈单位，64占两个栈单位。

- 栈顶缓存：因为操作数存储在内存中，为提高效率减小读写内存的次数，将栈顶元素缓存到CPU寄存器中来提高执行效率；
- 存储单位是栈，访问的方式不再是通过索引访问，而是入栈、出栈的方式，例如子程序返回的值会先入主程序的操作数栈，然后再出栈返回给主程序的变量值。

### 方法的调用

**静态链接**

被调用的方法在编译期可知，且运行期不变，称为静态链接。如：`System.out.println()`等静态方法。

> 会直接在编译期将调用方法的符号引用转换为直接引用（称为**早期绑定**）

**动态链接**

被调用的方法无法在编译期间确定，例如接口、继承和反射等，只能在运行期将调用方法的符号引用转换为直接引用（称为**晚期绑定**）。这种称为动态链接。

> 接口和继承是当子类实现/重写了父类的方法时，可能会出现动态链接

**非虚方法**

非虚方法通常包括：静态方法、`private`方法、`final`方法、构造方法等。因为这些方法无法被子类重写，在编译期就可以确定方法的版本，因此就不存在动态链接。

除开上述提到的非虚方法，Java中任意一个普通方法都是虚方法（晚期绑定）

**虚方法表**

为了提高执行效率，避免每次动态分配过程都要去类中方法的元数据中搜索，JVM会为每个类维护一个虚方法表。

- 表中存放各虚方法的实际入口
- 表在类加载的**链接阶段**创建和初始化

**方法重写的本质**（[待完善](https://doocs.gitee.io/jvm/01-jvm-memory-structure.html#%E6%96%B9%E6%B3%95%E7%9A%84%E8%B0%83%E7%94%A8)）

### Java虚拟机栈的特点

- 会出现的两种异常: `StackOverFlowError`, `OutOfMemoryError`
  - `StackOverFlow`: 设置了Java虚拟机栈的大小不允许**动态扩展**，当线程请求的栈深度超过Java虚拟机栈的最大深度时会抛出该异常；
  - `OutOfMemory`: 允许Java虚拟机栈动态扩展，但是当扩展到内存用光的时候，就会抛出该异常
- Java虚拟机栈是线程私有的，生命周期同线程一样

## 本地方法栈(C栈)

**定义**

本地方法栈是为运行`native`方法准备的空间，`native`方法通常是由C语言实现。

与Java虚拟栈功能类似，两者都是内存模型。区别在于Java虚拟栈为Java方法服务，本地方法栈为`native`方法服务。

本地方法执行时，同样会创建活动栈用于存放局部变量表、操作数栈、动态链接、方法出口信息等。方法结束后出栈释放资源。同时也会抛出`StackOverFlow`和`OutOfMemory`异常。