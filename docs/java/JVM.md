- [内存结构](#内存结构)
  - [程序计数器PC](#程序计数器pc)
  - [Java虚拟机栈(Java 栈)](#java虚拟机栈java-栈)
    - [方法的调用](#方法的调用)
    - [Java虚拟机栈的特点](#java虚拟机栈的特点)
  - [本地方法栈(C栈)](#本地方法栈c栈)
  - [堆](#堆)
    - [特点](#特点)
    - [新生代和老年代](#新生代和老年代)
    - [Full GC和Major GC](#full-gc和major-gc)
    - [逃逸分析](#逃逸分析)
    - [TLAB](#tlab)
    - [四种引用方式](#四种引用方式)
  - [方法区](#方法区)
    - [特点](#特点-1)
    - [运行时常量池](#运行时常量池)
  - [直接内存(堆外内存)](#直接内存堆外内存)
- [对象](#对象)
  - [对象的内存布局](#对象的内存布局)
    - [对象头](#对象头)
    - [实例数据](#实例数据)
    - [对齐填充](#对齐填充)
  - [对象的访问方式](#对象的访问方式)
    - [句柄访问](#句柄访问)
    - [直接访问](#直接访问)
- [IDEA的操作](#idea的操作)
  - [设置JVM参数](#设置jvm参数)
  - [分析堆内存](#分析堆内存)

# 内存结构

## 程序计数器PC

**定义**

是当前线程正在执行的那条**字节码**指令的地址。若当前线程正在执行的是一个本地方法，那么此时程序计数器为`Undefined`

[字节码解释器]()通过改变PC来依次读取指令，实现流程控制

**特点**

- 线程私有
- 生命周期随着线程创建而创建、结束而销毁
- 唯一不会`OutOfMemoryError`的内存区域

## Java虚拟机栈(Java 栈)

为每个即将运行的Java方法创建一个**栈帧**区域，如下图所示：

![20230412150205](https://raw.githubusercontent.com/PercivalYang/imgsSaving/main/imgs/20230412150205.png)

**活动栈**

当前栈帧又称**活动栈**，即当前正在执行的方法，只有这个栈帧中的本地变量能够被**操作数栈**使用。当方法结束栈帧被弹出时，当前方法的返回值会作为下一个活动栈中操作数栈的一个操作数。

**局部变量表**

用于存储方法参数、定义在方法体内的局部变量。如图所示包含了3种数据类型：基本类型、对象引用和return Address

> return Address: 通常视为一个指向地址的指针，指示程序执行完方法后该回到哪个位置继续执行

表的容量大小在**编译期间**就定下来了，方法运行期间表的大小不会改变

基本的存储单位是：`slot`。32位数据类型占1个slot，64位数据类型(long, double)占2个slot。

对于slot：

- JVM会对每一个slot分配一个访问索引，通过索引可以访问到局部变量值
- 当一个局部变量过了作用域后，它所占用的slot是可以被新的局部变量覆盖
- 若活动栈是构造方法，那么第一个slot是用来存储`this`的引用的 (这个目的是什么？)

局部变量表中直接或间接引用的对象，都不会被GC回收，因为这些变量是根结点。

**操作数栈**

用于存储计算过程中的中间结果，也是方法调用时的参数传递。操作数栈的容量大小也是在**编译期间**就确定下来了。32位数据类型占一个栈单位，64占两个栈单位。

- 栈顶缓存：因为操作数存储在内存中，为提高效率减小读写内存的次数，将栈顶元素缓存到CPU寄存器中来提高执行效率；
- 存储单位是栈，访问的方式不再是通过索引访问，而是入栈、出栈的方式，例如子程序返回的值会先入主程序的操作数栈，然后再出栈返回给主程序的变量值。

### 方法的调用

**静态链接**

被调用的方法在编译期可知，且运行期不变，称为静态链接。如：`System.out.println()`等静态方法。

> 会直接在编译期将调用方法的符号引用转换为直接引用（称为**早期绑定**）

**动态链接**

被调用的方法无法在编译期间确定，例如接口、继承和反射等，只能在运行期将调用方法的符号引用转换为直接引用（称为**晚期绑定**）。这种称为动态链接。

> 接口和继承是当子类实现/重写了父类的方法时，可能会出现动态链接

**非虚方法**

非虚方法通常包括：静态方法、`private`方法、`final`方法、构造方法等。因为这些方法无法被子类重写，在编译期就可以确定方法的版本，因此就不存在动态链接。

除开上述提到的非虚方法，Java中任意一个普通方法都是虚方法（晚期绑定）

**虚方法表**

为了提高执行效率，避免每次动态分配过程都要去类中方法的元数据中搜索，JVM会为每个类维护一个虚方法表。

- 表中存放各虚方法的实际入口
- 表在类加载的**链接阶段**创建和初始化

**方法重写的本质**（[待完善](https://doocs.gitee.io/jvm/01-jvm-memory-structure.html#%E6%96%B9%E6%B3%95%E7%9A%84%E8%B0%83%E7%94%A8)）

### Java虚拟机栈的特点

- 会出现的两种异常: `StackOverFlowError`, `OutOfMemoryError`
  - `StackOverFlow`: 设置了Java虚拟机栈的大小不允许**动态扩展**，当线程请求的栈深度超过Java虚拟机栈的最大深度时会抛出该异常；
  - `OutOfMemory`: 允许Java虚拟机栈动态扩展，但是当扩展到内存用光的时候，就会抛出该异常
- Java虚拟机栈是线程私有的，生命周期同线程一样

## 本地方法栈(C栈)

**定义**

本地方法栈是为运行`native`方法准备的空间，`native`方法通常是由C语言实现。

与Java虚拟栈功能类似，两者都是内存模型。区别在于Java虚拟栈为Java方法服务，本地方法栈为`native`方法服务。

本地方法执行时，同样会创建活动栈用于存放局部变量表、操作数栈、动态链接、方法出口信息等。方法结束后出栈释放资源。同时也会抛出`StackOverFlow`和`OutOfMemory`异常。

## 堆

### 特点

- 线程共享的，在JVM启动时创建，是GC的主要区域
- 分为新生代(Eden区：`From Survior`, `To Survior`)、老年代
- 堆可以在运行时动态扩展或收缩，但是在扩展时可能会出现`OutOfMemory`异常
- 堆可以处于物理不连续的内存空间，但是逻辑上是连续的

### 新生代和老年代

- 老年代生命周期更长；
- 新生代与老年代空间**默认比例 1:2**。XX:NewRatio=2，用来设置新生代和老年代内存大小比例，此处表示老年代的内存大小是新生代的2倍，则新生代占整个堆内存的1/3；
- HotSpot 中，Eden 空间和另外两个 Survivor 空间缺省所占的比例是：8:1:1。

> 这里的Eden空间和另外两个Survivor空间是否能补上图片说明？

- 几乎所有的 Java 对象都是在 Eden 区被 new 出来的，Eden 放不了的大对象，就直接进入老年代了。

### Full GC和Major GC

**触发条件**

- 老年代和方法区内存不足 $\rightarrow$ 触发Full GC；
- 回收新生代区会用Minor GC，当老年代内存还是不够时触发Major GC

**STW(Stop The World)**

- Full GC和Major GC都会触发STW，即在GC之前，所有的线程都会被暂停，直到GC结束，所有的线程才会被唤醒；
- Full GC STW 时间最长，Major GC STW 时间次之，Minor GC STW 时间最短。

### 逃逸分析

**方法逃逸**指对象定义在一个方法中，但是它可能被外部方法所引用，例如作为参数传递给外部方法，则称作方法逃逸，例如：（类似的还有**线程逃逸**）

```java
public static StringBuffer createStringBuffer(String s1, String s2) {

    StringBuffer s = new StringBuffer();

    s.append(s1);

    s.append(s2);

    return s;
}
```

> s是方法内的局部变量，但是上述代码将s作为返回值进行返回，即s可能会被外部方法所引用，因此发生了`方法逃逸`

逃逸分析是一种基于**指针分析**的**优化技术**，它的目的是分析**对象的作用域**，以此来决定是否在栈上分配对象，还是在堆上分配对象。

**标量替换**

标量对应Java中的基本数据类型，意思是不可再分的量。与之对应的就是**聚合量**，即可再分的量，如数组、对象等。

**替换过程**是通过逃逸分析确定该对象不会被外部访问，JVM在方法内不会创建该对象，而是分解对象的成员变量为方法内的替代变量。这样就不需要在堆上分配内存了，这些替代变量在栈或寄存器上分配空间

- 对象和数组不一定会分配在堆上，如果对象不会逃逸出方法，那么它就分配在栈上，这样就不需要GC来回收了。

**参数设置**

- `-XX:+DoEscapeAnalysis`：开启逃逸分析，jdk1.7之后默认开启；（`+`换成`-`就是关闭）

### TLAB

全称：Thread Local Allocation Buffer，即线程本地分配缓冲区。

因为堆是所有线程共享的，每次线程在堆上分配内存时都需要进行同步（JVM通过CAS实现同步）。

为了减少同步的开销，每个线程**预先**在堆中分配一块小内存，等到TLAB用完时分配新的TLAB时，才需要进行同步。

如果线程在TLAB中分配内存失败了，会使用加锁的机制来保证原子性。

- `-XX:+UseTLAB`: 开启TLAB，默认开启
- `-XX:+TLABSize`: 设置TLAB的大小，默认为1MB

### 四种引用方式

- 强引用：`Object obj = new Object()`，`obj`就是强引用变量，除非将`obj`赋值为`null`，否则即使JVM发生OOM，GC也不会回收强引用变量指向的堆上的变量；
- 弱引用：只要发生GC，都会进行回收
- 软引用：只有在内存不足时才会进行回收
- 虚引用：不会决定对象生命周期，该对象随时可能被GC回收

## 方法区

方法区是堆的一个**逻辑部份**。存放以下信息：

- 已经被虚拟机加载的类信息
- 常量
- 静态变量
- 即时编译器编译后的代码

### 特点

- 线程共享
- 永久代：方法区中的信息需要长期存在，称为永久代
- 回收效率低：变量都是永生代需要长期存在，因此一次GC只会有少数变量会被回收；
- 可以固定大小/动态扩展/不实现GC等。

### 运行时常量池

常量就存在其中。`.class`文件除了有类的版本、字段、方法、接口等描述信息，还有**常量池表**(Constant Pool Table)，用于存放编译期生成的字面量与符号引用，将在类加载后存入方法区中的运行时常量池。

同时运行时常量池具备**动态性**，可以在运行期间将新的常量加入池中，例如通过`String`的`intern()`方法。

> 用`new`显示创建字符串时，Java会创建新的实例对象(不论字符串常量池中是否存在该字符)，`intern`方法是将该String对象添加到字符串池中，如果池中已经存在该对象，则返回池中的对象。

## 直接内存(堆外内存)

JDK1.4种新加入**NIO**(New Input/Output)，引入一种基于管道和缓冲区的I/O方式。可以使用Native函数库直接申请堆外内存，然后用存储在Java堆中的`DirectByteBuffer`来引用这块堆外内存进行操作。

NIO的操作是非阻塞的，因此可以通过一个线程来管理多个通道，从而提高系统的并发性能。

# 对象

## 对象的内存布局

HotSpot的对象内存布局如下：

![](https://raw.githubusercontent.com/PercivalYang/imgsSaving/main/imgs/20230415221544.png)

### 对象头

记录了对象的元信息，包括：

`makrWord`:

- 哈希码
- GC 分代年龄
- 锁状态标志
- 线程持有的锁
- 偏向线程 ID
- 偏向时间戳

`Class对象指针`: 指明对象属于什么类

`数组长度(Optional)`：如果是数组，记录数组长度

### 实例数据

成员变量的值，其中包括父类成员变量和本类成员变量。

### 对齐填充

为了保证对象的大小是8字节的整数倍，可能会在对象头和实例数据之间添加一些填充字节。

> HotSpot VM 的自动内存管理系统要求对象的大小必须是 8 字节的整数倍，提高对象的访问效率
>
> 因为对齐填充帮助Java堆的内存是规整的，所有空闲区在一边，被使用区在另一边，中间有一个指针作为分界点。下次分配内存只用将指针移动和对象大小相同的距离，这个操作称为**指针碰撞**。

## 对象的访问方式

### 句柄访问

句柄的访问可以理解为间接访问，即在堆中申请一个"访问代理"，代理中包含了对象的实例数据和类型数据各自的具体地址信息，然后通过访问代理来访问对象。如下图所示

![20230417173021](https://raw.githubusercontent.com/PercivalYang/imgsSaving/main/imgs/20230417173021.png)

### 直接访问

直接访问是省去了代理，直接访问对象的实例数据和类型数据。如下图所示

![20230417173136](https://raw.githubusercontent.com/PercivalYang/imgsSaving/main/imgs/20230417173136.png)


# IDEA的操作

 IDEA版本：2022.3.1(Ultimate Edition)

## 设置JVM参数

![20230417180104](https://raw.githubusercontent.com/PercivalYang/imgsSaving/main/imgs/20230417180104.png)

在`Edit Configuration`中，如果没有VM options的话，如上图操作添加上即可；


## 分析堆内存

**Debug过程中**：

![20230417180353](https://raw.githubusercontent.com/PercivalYang/imgsSaving/main/imgs/20230417180353.png)

要把Debug中的`Memory`视图打开

**使用memory快照**：

[官方教程](https://www.jetbrains.com/help/idea/create-a-memory-snapshot.html)

![20230417180617](https://raw.githubusercontent.com/PercivalYang/imgsSaving/main/imgs/20230417180617.png)

捕获的快照`.hprof`文件中可以查看对象的创建个数等，如下图：

![20230417180722](https://raw.githubusercontent.com/PercivalYang/imgsSaving/main/imgs/20230417180722.png)