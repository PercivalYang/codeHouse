- [UML图](#uml图)
  - [类图](#类图)
    - [关联关系](#关联关系)
    - [聚合关系](#聚合关系)
    - [组合关系](#组合关系)
    - [依赖关系](#依赖关系)
    - [继承关系](#继承关系)
    - [实现关系](#实现关系)
- [七大原则](#七大原则)
  - [单一职责原则](#单一职责原则)
  - [接口隔离原则](#接口隔离原则)
  - [开闭原则](#开闭原则)
  - [里氏代换原则](#里氏代换原则)
  - [依赖倒置原则](#依赖倒置原则)
  - [迪米特法则](#迪米特法则)
  - [合成复用原则](#合成复用原则)
- [创建型模式](#创建型模式)
  - [单例模式](#单例模式)
  - [工厂模式](#工厂模式)
    - [简单工厂模式](#简单工厂模式)
    - [工厂方法模式](#工厂方法模式)
    - [抽象工厂模式](#抽象工厂模式)
  - [原型模式](#原型模式)
  - [建造者模式](#建造者模式)

# UML图

UML：Unified Modeling Language，即统一建模语言，用于描述软件系统中的静态结构和动态行为。

UML图包括类图、例图、对象图、状态图、活动图、时序图、协作图、构件图、部署图等9种图

## 类图

显示了模型中存在的类、类的内部结构以及与其他类之间的关系

![classDiagram](https://raw.githubusercontent.com/PercivalYang/imgsSaving/main/imgs/classDiagram.png)

- +：表示public
- -：表示private
- #：表示protected

类之间存在不同的关系，如关联关系、聚合关系、组合关系、依赖关系、泛化关系、实现关系等，类图中对他们的不同表现方式如下所述。

### 关联关系

首先介绍强关联关系，都是由实线和实心箭头表示，可分为单向关联、双向关联和自关联，其中双向关联不存在箭头符号，自关联如下图所示

![selfRele](https://raw.githubusercontent.com/PercivalYang/imgsSaving/main/imgs/selfRele.png)

### 聚合关系

聚合关系是一种弱的关联关系，体现的是A对象可以包含B对象，但B对象不是A对象的一部分，通常由空心菱形表示，如下图所示

![weakRele](https://raw.githubusercontent.com/PercivalYang/imgsSaving/main/imgs/weakRele.png)

进一步解释，聚合关系是部份与整体之间的关系（例如一个机器由多个零件组成，机器是整体，零件是部份）；而关联关系是两个独立的类之间的关系，例如学生和老师之间的关系。

### 组合关系

是一种更强的聚合关系，在于整体对象可以控制部份对象的生命周期，一旦整体对象不存在，则部份对象也无法独立存在。通常由实心菱形表示：

![zuhe](https://raw.githubusercontent.com/PercivalYang/imgsSaving/main/imgs/zuhe.png)

### 依赖关系

是**临时性**的关联，耦合度最弱。例如计算器只会在计算学生GPA时调用学生类，计算完成之后他们之间的关系就解除了，因此学生类和计算器类是依赖关系。通常用虚线进行表示，如下图所示：

![yilai](https://raw.githubusercontent.com/PercivalYang/imgsSaving/main/imgs/yilai.png)

### 继承关系

是**耦合度最大**的一种，通常用实线加空心三角形表示，如下图所示：

![jicheng](https://raw.githubusercontent.com/PercivalYang/imgsSaving/main/imgs/jicheng.png)

### 实现关系

通常用空心三角加虚线表示，如下图：

![shixian](https://raw.githubusercontent.com/PercivalYang/imgsSaving/main/imgs/shixian.png)

# 七大原则

## 单一职责原则

- 一个类只负责一项职责
- 目的：提高类的可读性、可维护性，降低变更风险

## 接口隔离原则

- 客户端不能被迫依赖于它不使用的方法；应该将大接口划分为精细的小接口。
- 目的：提高代码灵活度、可扩展性和可维护性

## 开闭原则

- 对扩展开放，对修改关闭。核心思想是软件实体依赖的是接口或者抽象类，这样在拓展新功能时可以避免修改原有代码，而是通过实现接口或者继承抽象类来实现新功能。例如：

- 搜狗输入法的皮肤可以定义为一个抽象类，不同的皮肤可以继承该抽象类，这样在添加新的皮肤时，只需要继承该抽象类即可，而不需要修改原有代码。

![kaibi](https://raw.githubusercontent.com/PercivalYang/imgsSaving/main/imgs/kaibi.png)

## 里氏代换原则

- 子类可以扩展父类的功能，但不能改变父类原有的功能
- 如果重写父类的方法，整个继承体系的可复用性会很差，导致在多态频繁使用的场景下可能会出现问题(例如矩形的`resize`方法对长方形有效，对正方形会陷入死循环，详情见黑马讲义)。

## 依赖倒置原则

- 高层模块不应该依赖底层模块的具体实现，二者都应该依赖其抽象
- 例如组装电脑，电脑的组装过程不应该依赖具体的品牌（如Intel CPU，金士顿内存、希捷硬盘等），而是依赖于品牌的抽象（即CPU、内存、硬盘等）。这样可以提高用户的灵活度，用户挑选的组件只需要实现接口的方法即可

## 迪米特法则

又称最少知识原则。即如果两个实体无须直接通信，那么就不用发生直接调用，可以通过第三发转发该调用。例如明星和代理人，明星不需要和粉丝、媒体公司等产生直接调用关系，而是交由代理人处理，如下图所示：

![dimite](https://raw.githubusercontent.com/PercivalYang/imgsSaving/main/imgs/dimite.png)

- 当明星需要和粉丝交流或和媒体公司开会，则可以通过代理人发起`meeting`或`business`方法

## 合成复用原则

尽量使用合成/聚合的方式，而不是使用继承，例如下图所示：

![hecheng_jicheng](https://raw.githubusercontent.com/PercivalYang/imgsSaving/main/imgs/hecheng_jicheng.png)

- 通过继承的关系将Car分为电车和油车，但是若要添加不同颜色的车型，则需要再次使用继承关系，大大降低了代码的复用性。因此将继承关系调整为聚合关系，如下图所示：

![hc](https://raw.githubusercontent.com/PercivalYang/imgsSaving/main/imgs/hc.png)

- 通过聚合关系，可以将颜色抽象为Car的一个接口，这样不需要在通过继承父类来添加不同颜色的车型，降低了系统的耦合度

# 创建型模式

## 单例模式

包含两个角色：**单例类**、**访问类**，单例类指的是只能创建一个对象的类，访问类指的是通过单例类创建对象的类。例如：

```java
public class Singleton {
    private static Singleton instance = new Singleton();
    private Singleton() {}
    public static Singleton getInstance() {
        return instance;
    }
}
```

其中，`Singleton`类是单例类，`getInstance`方法是访问类，通过该方法可以获取到`Singleton`类的唯一实例。

**实现**

有两种实现：

- 饿汉式：单例类加载时就创建实例，线程安全，但是可能造成内存浪费
- 懒汉式：单例类加载时不创建实例，只有在第一次调用`getInstance`方法时才创建实例，线程不安全，需要加锁

1. 饿汉式

例如上面的代码块就是饿汉式，同样可以改写为静态代码块的初始方法，如下：

```java
public class Singleton {
    private static Singleton instance;
    static{
        instance = new Singleton();
    }
    private Singleton() {}
    public static Singleton getInstance() {
        return instance;
    }
}
```

还可以通过枚举方式实现，如下：

```java
public enum Singleton {
    INSTANCE;
}
```

> 枚举方式是单例实现中**唯一**不会被破坏的单例实现模式

2. 懒汉式

对于懒汉式的实现方法如下，在声明`Singleton`类时不会给`instance`赋值，而是在调用`getInstance`方法后才赋值。但是这种实现方法是线程不安全的，因此需要加锁，如下：

```java
public class Singleton {
    private static Singleton instance;
    private Singleton() {}
    public static synchronized Singleton getInstance() {
        if (instance == null) {
            instance = new Singleton();
        }
        return instance;
    }
}
```

a. **双重检查锁方式**

但是对于`getInstance`来说绝大部分读操作，直接加锁的方式会让效率降低，因此需要调整加锁的时机，由此产生：**双重检查锁模式**，如下：

```java
public class Singleton {
    private static Singleton instance;
    private Singleton() {}
    public static Singleton getInstance() {
        if (instance == null) {
            synchronized (Singleton.class) {
                if (instance == null) {
                    instance = new Singleton();
                }
            }
        }
        return instance;
    }
}
```

但是双重检查锁模式存在问题，即**指令重排**，在多线程环境下，由于编译器优化重排的缘故，有可能会出现`instance = new Singleton()`的执行顺序颠倒的情况，即先给`instance`赋值，再执行构造方法，这样就会导致`instance`不为空，但是对象还没有初始化完成，因此需要在`instance`前面加上`volatile`关键字，如下：

```java
public class Singleton {
    private static volatile Singleton instance;
    private Singleton() {}
    public static Singleton getInstance() {
        if (instance == null) {
            synchronized (Singleton.class) {
                if (instance == null) {
                    instance = new Singleton();
                }
            }
        }
        return instance;
    }
}
```

b. **静态内部类方式**

由于JVM在加载外部类时，不会加载**静态内部类**，因此可以通过静态内部类的方式实现单例模式，如下：

```java
public class Singleton {
    private Singleton() {}
    // 静态内部类只在调用getInstance时才会加载
    private static class SingletonHolder {
        private static final Singleton INSTANCE = new Singleton();
    }
    public static final Singleton getInstance() {
        return SingletonHolder.INSTANCE;
    }
}
```

**破坏单例模式**

除开枚举类创建单例模式，之前所说的其他几种方式都有可能被破坏单例模式，即创建多个对象，主要通过反射和序列化两种方式来破坏，如下：

1. 反射

```java
public class Test {
    public static void main(String[] args) throws Exception {
        Class clazz = Class.forName("Singleton");
        Constructor constructor = clazz.getDeclaredConstructor(null);
        constructor.setAccessible(true);
        // 通过反射调取getInstance方法，来返回多个不同对象
        Singleton s1 = (Singleton) constructor.getInstance();
        Singleton s2 = (Singleton) constructor.getInstance();
        System.out.println(s1 == s2);
    }
}
```

**解决方案**

- 通过在构造方法中添加判断，如果`instance`不为空，则抛出异常，如下：

```java
public class Singleton {
    private static Singleton instance;
    private Singleton() {
        // 在构造方法中加入判断，禁止反射调用
        if (instance != null) {
            throw new RuntimeException("单例模式禁止反射调用");
        }
    }
    ...
}
```

2. 序列化

序列化将对象转换为字节序列的过程，而反序列化则是将字节序列恢复为对象的过程，同时反序列化时会通过反射机制调用无参构造方法来一个新的对象，这样就破坏了单例模式

**解决方案**

- 重写`readResolve`方法，如下：

```java
public class Singleton implements Serializable {
    private static final long serialVersionUID = 1L;
    private static Singleton instance;
    private Singleton() {}
    public static Singleton getInstance() {
        if (instance == null) {
            synchronized (Singleton.class) {
                if (instance == null) {
                    instance = new Singleton();
                }
            }
        }
        return instance;
    }
    // 反序列化时返回之前创建的单例对象
    private Object readResolve() {
        return instance;
    }
}
```

> 为什么序列化不能破坏枚举方式的单例模式？
>
> A：因为在反序列化时会调用`readResolve`方法，而枚举类没有`readResolve`方法，因此不会创建新的对象

## 工厂模式

工厂模式最大的特点是：**解耦**。因为创建对象时直接new对象会导致对该对象的耦合度很高（假如要更换对象，则需要将所有new对象的地方都更换，而这就**违反了开闭原则**）。因此我们通过工厂来进行解耦，如果需要更换对象，直接在工厂里更换即可。

### 简单工厂模式

这里不对简单工厂做细致讲解，因为简单工厂的缺点是：**违反了开闭原则**，如下：

```java
public class SimpleCoffeeFactory { 

    public Coffee createCoffee(String type) { 
        Coffee coffee = null; 
        if("americano".equals(type)) { 
            coffee = new AmericanoCoffee(); 
        } else if("latte".equals(type)) { 
            coffee = new LatteCoffee();
        }
        return coffee; 
    } 
}
```

虽然我们可以通过输入不同的`type`来创造不同的对象，解耦了对象创建的过程。但是如果要添加新的对象，简单工厂模式还是需要修改源代码的`createCoffee`方法，这就违法了开闭原则

### 工厂方法模式

工厂方法模式遵循了开闭原则，它里面包含的主要角色有：

- 抽象工厂：提供了创建产品的接口，定义了具体工厂必须实现的方法（如`CoffeeFactory`，简单工厂不包含该角色）
- 具体工厂：实现了抽象工厂中的方法，完成具体产品的创建（如`ChineseCoffeeFactory`、`AmericanCoffeeFactory`）
- 抽象产品：定义了产品的规范，描述了产品的主要特性和功能（如`Coffee`）
- 具体产品：实现抽象产品的特性和功能（如`ChineseCoffee`）

例如：

![20230412144220](https://raw.githubusercontent.com/PercivalYang/imgsSaving/main/imgs/20230412144220.png)

这样在系统增加新的产品时，只需添加具体产品类和工厂类，不需要对原工厂代码进行修改，满足了开闭原则

### 抽象工厂模式

抽象工厂模式引入了**产品族**，举例说明：例如一个生产手机、电脑和耳机的工厂，苹果品牌的手机、电脑和耳机都属于同一个产品族，同理华为的手机、电脑和耳机也属于另一个产品族。

抽象工厂和工厂方法模式不同的是，生产的不再是单一的产品，而是一个产品族。例如把上面的电子工厂换成先前的咖啡店。

![抽象工厂](https://raw.githubusercontent.com/PercivalYang/imgsSaving/main/imgs/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82.png)

根据上面的类图可以看出，如`AmericanDesserFactory`生产的不再是单一的咖啡，而是咖啡+甜点的产品族。

那么产品族的好处是什么呢？目前来说我的理解是能够保证客户使用的对象都是在同一个产品族下，通常一个产品族下不会发生兼容性问题（例如苹果生态的手机和Windows电脑之间就没有隔空投送功能）

但是缺点也很明显，如果要在产品族中新增一个产品，则需要对原工厂接口进行修改，这样所有的工厂实现类都要修改。

## 原型模式

![原型模式](https://raw.githubusercontent.com/PercivalYang/imgsSaving/main/imgs/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F.png)

原型模式的原型是一个已创建的实例，然后通过`clone`方法复制该原型来创建一个和原型对象相同的新对象

克隆分为：

- 浅克隆：新对象属性和原型相同，非基本类型的对象还是指向原型对象的内存地址
- 深克隆：非基本类型对象也会被克隆，不再指向原型对象的内存地址

对于原型对象的成员属性只有基本类型和String时，使用浅克隆即可，但如果原型对象的成员属性有引用对象，则需要使用深克隆

> 深克隆的方式是通过**对象流**来实现的

## 建造者模式

和工厂模式不同的是，建造者模式更注重对象创建的**过程**，通常有`Builder`负责创建对象，`Director`负责将创建的对象进行装配。所以从另一方面也可看出，建造者模式是针对复杂对象的一种设计模式。

![建造者模式](https://raw.githubusercontent.com/PercivalYang/imgsSaving/main/imgs/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F.png)

例如上面的例子，创建不同类型的单车，先看`Client`中的`showBike`方法如下：

```java
public class Client {
    public static void main(String[] args) {
        showBike(new OfoBuilder());
        showBike(new MobikeBuilder());
    }
    private static void showBike(Builder builder) {
        Director director = new Director(builder); 
        Bike bike = director.construct();
        System.out.println(bike.getFrame()); 
        System.out.println(bike.getSeat()); 
        } 
}
```

`showBike`方法中创建一个`Bike`实例对象是通过调用装配器`director`来实现的，而装配器的`construct`方法实现如下：

```java
...
    private Builder mBuilder;
    public Bike construct() {
        // buildFrame指构建车的车架
        mBuilder.buildFrame();
        // buildSeat指构建车的车座
        // 现实中车座通常要有车架才能构建的，所以在Director中我们可以控制装配的顺序
        mBuilder.buildSeat(); 
        // 待所有零件都装配好了，返回完整的Bike对象
        return mBuilder.createBike(); 
    }
...
```

而`Builder`可以用一个抽象类来实现，如下所示：

```java
public abstract class Builder {
    protected Bike mBike = new Bike(); 

    public abstract void buildFrame(); 
    public abstract void buildSeat(); 
    public abstract Bike createBike(); 
}
```

这样对于不同的单车，例如'摩拜'和'ofo'，只需要实现`Builder`的抽象方法即可
